@startuml
title 
Example realtime workflow with a custom driver script

end title
|c| User's ICS-WNTR link class
|d| User's custom driver script
|w| WNTR RealtimeSimulator class
|d|
start
:Load configuration, ""config""
and WDS network model, ""wn"";
:Delete any rules or controls in the 
""wn"" model so that all control is 
external.;
:Create link object ""myicslink"";
|c|
:<code>
__init__(*args, **kwargs)
</code>;
|d|
:Create WNTR simulator, ""sim"";
|w|
:<code>
__init__(wn, **kwargs)
</code>;
|d|
while (sensors to configure?) is (yes)
:call ""sim.add_sensor_instrument(**kwargs)""
or ""sim.add_controller_instrument(**kwargs)"";
|w|
:maps ICS entries to ""wn"" model elements;
endwhile
->no;
|d|
:Initialize simulator
""sim.initialize(**kwargs)"";
|w| 
:Maps internal simulator commands to 
functions on communicator. E.g.:
<code>
self.transmit := myicslink.some_function_1
self.receive := myicslink.some_function_2
self.stop := myicslink.some_other_function
</code>;
:run hydraulic timestep for ""ts = 0"";
|d|
:Run WNTR simulation
""sim.run_sim(limit=?, cleanup=True)"";
|w|
repeat 
:Ask ISC link for new data
""ics_values = self.receive(ts)"";
-> pass sim time as an integer;
|c|
:Get commands from ICS; e.g.,
from network traffic messages or
from some user-coded control rules>
-> return values in a dictionary;
|w|
:Set new statuses in simulator
""self._set_sensor_values(ics_values)"";
:Run one simulation timestep and
calculate new hydraulic/water quality
values for the simulation, 
advance timestep ""ts"";
:Get the data from the new simulation state 
""new_values = self._get_sensor_values()"";
:Send the data to the ICS link
""self.transmit(ts, new_values)"";
-> pass values in a dictionary;
|c|
:Relay sensor values to ICS; e.g.,
as network messages or
by writing to a database or file<
-> no return value;
|w|
:Check for terminate signal
""done = self.stop(ts)"";
-> pass sim time as integer;
|c|
:Execute user's custom code to do clock 
synchronization and/or look for a 
termination/kill signal from the 
outside ICS simulator.
return ""True"" if it is time to stop>
-> return a boolean;
|w|
:Check runtime limits;
repeat while (""ts < limit and not done""?) is (yes)
->no;
if (cleanup) is (always yes for this example) then
:end simulation completely;
else 
-[hidden]->
endif
|d|
:Close simulator
""results = sim.close()"";
|w|
:Close all DLLs, write report;
:Create a WNTR results object
and return it to the user's driver;
-> return ""wntr.sim.Results"" object;
|d|
:Do custom postprocessing as 
written by the user;
stop

@enduml
